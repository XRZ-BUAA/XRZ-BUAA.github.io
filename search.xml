<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Chapter 1 —— Mistakes I made</title>
      <link href="/2024/11/25/Mathematical%20Analysis/Chapter1_errors/"/>
      <url>/2024/11/25/Mathematical%20Analysis/Chapter1_errors/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-——-错题记录"><a href="#第一章-——-错题记录" class="headerlink" title="第一章 —— 错题记录"></a>第一章 —— 错题记录</h1><p><strong>错题一</strong><br>判断对错：两图像关于直线 $y=x$ 对称，则它们互为反函数<br>我: ✔<br>正解: ×<br>解析：<strong>反函数的存在</strong> 必须是一个前提。反函数和其原函数图像必然关于直线 $y=x$ 对称，但<strong>两个图像关于直线 $y=x$ 对称的函数不一定存在反函数</strong>。比如 $y=x^2$ 和 $y=\sqrt{x}$ 关于直线 $y=x$ 对称，但 $y=x^2$ 没有反函数，只有削减其定义域至 $x \in [0, \infty)$ 后两者才互为反函数。<br>记住：<strong>两图像关于直线 $y=x$ 对称，但它们不一定互为反函数</strong>  </p>]]></content>
      
      
      <categories>
          
          <category> CalcuNote </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA-Course-Notes </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter 1 —— Sets and Mappings</title>
      <link href="/2024/10/18/Mathematical%20Analysis/sets_and_mappings/"/>
      <url>/2024/10/18/Mathematical%20Analysis/sets_and_mappings/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-——-集合与映射"><a href="#第一章-——-集合与映射" class="headerlink" title="第一章 —— 集合与映射"></a>第一章 —— 集合与映射</h1><h2 id="1-1-集合"><a href="#1-1-集合" class="headerlink" title="1.1 集合"></a>1.1 集合</h2><h3 id="1-1-1-集合的概念"><a href="#1-1-1-集合的概念" class="headerlink" title="1.1.1 集合的概念"></a>1.1.1 集合的概念</h3><p>说一下集合的相等<br>给定两个集合 $A$ 和 $B$，若既有 $A \subseteq B$ 又有 $B \subseteq A$，则称 $A$ 和 $B$ 是相等的，记作 $A = B$  </p><blockquote><p>这个概念常用于证明题，当要求证明两集合相等时，首先想到证明“两个包含”  </p></blockquote><h3 id="1-1-2-集合的运算"><a href="#1-1-2-集合的运算" class="headerlink" title="1.1.2 集合的运算"></a>1.1.2 集合的运算</h3><p>主要介绍了集合的四种基本运算：<strong>并、交、补、差</strong>，以及两个集合之间的 <strong>笛卡尔积</strong>  </p><h4 id="运算的定义"><a href="#运算的定义" class="headerlink" title="运算的定义"></a>运算的定义</h4><p>关于运算的定义，主要说一下 <strong>差、补</strong> 和 <strong>笛卡尔积</strong>  </p><h5 id="集合的差运算"><a href="#集合的差运算" class="headerlink" title="集合的差运算"></a>集合的差运算</h5><p>给定两个集合 $A, B$，记  </p><script type="math/tex; mode=display">A \setminus B = \{x | x \in A \text{ and } x \notin B \}</script><p>它表示属于 $A$ 但不属于 $B$ 的元素构成的集合，称为 $A$ 与 $B$ 的差集<br><strong>注意</strong>  这里没有要求 $B$ 是 $A$ 的子集  </p><h5 id="集合的补运算"><a href="#集合的补运算" class="headerlink" title="集合的补运算"></a>集合的补运算</h5><p><strong>全集</strong> 当所考虑的集合总是某个集合 $X$ 的子集时，往往称 $X$ 为全集  </p><p>对于全集 $X$ 的一个子集 $A$，将集合 $X \setminus A$ 称为 $A$ 的补集，记 $\complement_XA$ 或 $A ^\complement$. 在同一个全集中，补和差的运算满足如下关系：  </p><script type="math/tex; mode=display">A \setminus B = \complement_AB = A \cap \complement_SB</script><h5 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h5><p>给定集合 $A, B$，记  </p><script type="math/tex; mode=display">A \times B = \{(a, b) | a \in A, b \in B\}</script><p>它表示 $A$ 和 $B$ 的笛卡尔积<br>可以记 $\mathbb{R}^2 = \mathbb{R} \times \mathbb{R}$, $\mathbb{R}^3 = \mathbb{R} \times \mathbb{R} \times \mathbb{R}$ 等等  </p><h4 id="运算的性质"><a href="#运算的性质" class="headerlink" title="运算的性质"></a>运算的性质</h4><p>上面介绍的几种集合运算满足如下性质：   </p><ul><li><strong>交换律</strong> $A \cup B = B \cup A$, $A \cap B = B \cap A$  </li><li><strong>结合律</strong> $(A \cup B) \cup C = A \cup (B \cup C)$, $(A \cap B) \cap C = A \cap (B \cap C)$  </li><li><strong>分配律</strong> $A \cup (B \cap C) = (A \cup B) \cap (A \cup C)$, $A \cap (B \cup C) = (A \cap B) \cup (A \cap C)$  </li><li><strong>德摩根律</strong> $(A \cup B) ^\complement = A ^\complement \cap B ^\complement$, $(A \cap B) ^\complement = A ^\complement \cup B ^\complement$  </li></ul><hr><h2 id="1-2-映射与函数"><a href="#1-2-映射与函数" class="headerlink" title="1.2 映射与函数"></a>1.2 映射与函数</h2><h3 id="1-2-1-集合之间的映射"><a href="#1-2-1-集合之间的映射" class="headerlink" title="1.2.1 集合之间的映射"></a>1.2.1 集合之间的映射</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>（教材P4 <code>定义1.2.1</code>）  </p><h5 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h5><p>给定两个集合 $X, Y$，若 $f$ 是 $X$ 和 $Y$ 之间的对应关系，且满足：$\forall x \in X, \exists$ <strong>唯一的元素</strong>  $y$ 与之对应，则称 $f$ 为 $X$ 到 $Y$ 的一个映射，记为  </p><script type="math/tex; mode=display">f: X \rightarrow Y \qquad x \mapsto y</script><h5 id="像与域"><a href="#像与域" class="headerlink" title="像与域"></a>像与域</h5><p>设 $x \in X$，则 $x$ 对应的位于 $Y$ 中的元素 $y$ 为 $x$ 在映射 $f$ 下的 <strong>像</strong>，记为 $f(x)$，若 $f(x) = y$ ，此时也称 $x$ 为 $y$ 的一个 <strong>逆像</strong> 或 <strong>原像</strong>，集合 $X$ 称为映射 $f$ 的 <strong>定义域</strong>，记为 $D_f$，所有 $X$ 中元素在映射 $f$ 作用下的 <strong>像</strong> 的全体构成的集合称为映射 $f$ 的 <strong>值域</strong>，记为 $R_f$，即  </p><script type="math/tex; mode=display">R_f = \{y | y \in Y, \exists x \in X, s.t. f(x) = y\}</script><p>给定一个映射 $f:X\rightarrow Y$，对于 $X$ 的一个子集 $A$，记  </p><script type="math/tex; mode=display">f(A) = \{ f(x) | x \in A \}，</script><p>它是 $Y$ 的一个子集，称之为 $A$ 在映射 $f$ 下的像. 对于 $Y$ 的一个子集 $B$，记   </p><script type="math/tex; mode=display">f^{-1}(B) = \{ x \in X | f(x) \in B \},</script><p>它是 $X$ 的一个子集，称之为 $B$ 在映射 $f$ 下的<strong>逆像</strong>或<strong>原像</strong>   </p><h5 id="映射三要素"><a href="#映射三要素" class="headerlink" title="映射三要素"></a>映射三要素</h5><p>构成一个映射有三个要素：  </p><ul><li>定义域 $X$</li><li>值域所在集合 $Y$</li><li>对应规则 $f$  </li></ul><p><strong>注意</strong>  </p><ul><li>映射要求元素的像是唯一确定的</li><li>映射并不要求 $Y$ 中元素的逆像是唯一确定的  </li></ul><h5 id="映射的相等"><a href="#映射的相等" class="headerlink" title="映射的相等"></a>映射的相等</h5><p>设 $f$ 和 $g$ 都是集合 $X$ 到集合 $Y$ 的映射，若 $\forall x \in X, f(x) = g(x)$，则称 $f$ 和 $g$ 是相等的，记作 $f = g$   </p><h5 id="特殊映射"><a href="#特殊映射" class="headerlink" title="特殊映射"></a>特殊映射</h5><p>（教材P5 <code>定义1.2.2</code>）<br>这一部分主要介绍 <strong>单射、满射、双射、（可）逆映射</strong>  </p><h6 id="单射"><a href="#单射" class="headerlink" title="单射"></a>单射</h6><p>设 $f:X\rightarrow Y$ 是 $X$ 到 $Y$ 的一个映射，若 $\forall x_1, x_2 \in X, x_1 \neq x_2 \Rightarrow f(x_1) \neq f(x_2)$，则称 $f$ 为一个单射  </p><h6 id="满射"><a href="#满射" class="headerlink" title="满射"></a>满射</h6><p>设 $f:X\rightarrow Y$ 是 $X$ 到 $Y$ 的一个映射，若 $\forall y \in Y, \exists x \in X$ 使得 $f(x) = y$，则称 $f$ 为一个满射  </p><h6 id="双射"><a href="#双射" class="headerlink" title="双射"></a>双射</h6><p>如果 $f$ 既是一个单射，又是一个满射，则称 $f$ 为一个 <strong>双射</strong> 或 <strong>一一映射</strong>  </p>]]></content>
      
      
      <categories>
          
          <category> CalcuNote </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA-Course-Notes </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AlgoNote-Introduction</title>
      <link href="/2024/10/02/Algorithms/AlgoNote-Introduction/"/>
      <url>/2024/10/02/Algorithms/AlgoNote-Introduction/</url>
      
        <content type="html"><![CDATA[<h1 id="初识算法"><a href="#初识算法" class="headerlink" title="初识算法"></a>初识算法</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p><strong>算法</strong> 定义良好的计算过程，取一个或一组值作为<strong>输入</strong>，并产生出一个或一组值作为<strong>输出</strong><br><strong>实例 (Instance)</strong> 某一个问题的实例包含了求解该问题所需要的输入（满足有关该问题表述中所给出的任何限制）  </p><p>如果一个算法对其每一个输入实例都能输出正确的结果并<strong>停止</strong>，则称这个算法是正确的  </p><h2 id="形式化定义"><a href="#形式化定义" class="headerlink" title="形式化定义"></a>形式化定义</h2><p><strong>排序问题</strong><br><strong>输入</strong> $n$ 个数 &lt;$a_1,a_2,…,a_n$&gt;<br><strong>输出</strong> 输入序列的一个排列 &lt;$a_1’,a_2’,…,a_n’$&gt;，使得 $a_1’ \leq a_2’ \leq… \leq a_n’$<br>可把待排序的数称为<strong>关键字 (key)</strong>  </p><h2 id="算法的表示——伪代码-Pseudocode"><a href="#算法的表示——伪代码-Pseudocode" class="headerlink" title="算法的表示——伪代码 (Pseudocode)"></a>算法的表示——伪代码 (Pseudocode)</h2><p>伪代码的书写格式按照课程组 PPT 上写的来<br>PPT 中给出的示例——选择排序：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入：数组 A[a_1, a_2, ..., a_n]</span><br><span class="line">输出：数组 A[a_1&#x27;, a_2&#x27;, ..., a_n&#x27;]，使得 a_1&#x27; &lt;= a_2&#x27; &lt;= ... &lt;= a_n&#x27;  </span><br><span class="line">for i &lt;- 1 to n-1 do</span><br><span class="line">    cur_min &lt;- A[i]</span><br><span class="line">    cur_min_pos &lt;- i</span><br><span class="line">    for j &lt;- i+1 to n do</span><br><span class="line">        if A[j] &lt; cur_min then</span><br><span class="line">            // 记录当前最小值及其位置</span><br><span class="line">            cur_min &lt;- A[j]</span><br><span class="line">            cur_min_pos &lt;- j</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    交换 A[i] 和 A[cur_min_pos]</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>可以从示例中看出伪代码书写的几个要点：  </p><ul><li>首行定义算法输入和输出</li><li>语句块缩进 （类似 Python 中的缩进）</li><li>赋值语句使用 <code>&lt;-</code> 符号</li><li>注释使用 <code>//</code> 符号</li><li>两个变量交换值时，我们不关注交换过程的实现细节</li><li>循环语句块包含在 <code>do-end</code> 语句中</li><li>条件语句块包含在 <code>then-end</code> 语句中</li></ul><h2 id="算法入门"><a href="#算法入门" class="headerlink" title="算法入门"></a>算法入门</h2><h3 id="循环不变式"><a href="#循环不变式" class="headerlink" title="循环不变式"></a>循环不变式</h3><p>循环不变式 (Loop Invariant) 可用来帮助我们理解和证明算法的正确性，在循环不变式中，要证明算法的正确性，必须证明它的三个性质：  </p><ul><li><strong>初始化</strong> 算法在循环的第一轮迭代开始前是正确的</li><li><strong>保持</strong> 如果在循环的某次迭代开始前它是正确的，那么在下一次迭代开始前它也应该保持正确  </li><li><strong>终止</strong> 当循环结束时，不变式给了我们一个有用的性质，它有助于表明算法是正确的  </li></ul><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>插入排序算法用于解决排序问题，是一个对<strong>少量</strong>元素进行排序的有效算法  </p><h4 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h4><p>插入排序的伪代码 (Pseudocode) 以一个过程的形式给出 —— INSETION-SORT：<br>《算法导论》 给出的伪代码如下：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">INSERTION-SORT(A)</span><br><span class="line">    for j &lt;- 2 to length[A]</span><br><span class="line">        do key &lt;- A[j]</span><br><span class="line">        // Insert A[j] into the sorted sequence A[1..j-1]</span><br><span class="line">        i &lt;- j - 1</span><br><span class="line">        while i &gt; 0 and A[i] &gt; key</span><br><span class="line">            do A[i+1] &lt;- A[i]</span><br><span class="line">                i &lt;- i - 1</span><br><span class="line">        A[i+1] &lt;- key</span><br></pre></td></tr></table></figure><p>它似乎是认为数组下标从 <code>1</code> 开始的？<br>按照《算法导论》给出的伪代码写了一个 C++ 实现：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        <span class="type">int</span> key = arr[j];</span><br><span class="line">        <span class="type">int</span> i = j - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; arr[i] &gt; key) &#123;</span><br><span class="line">            arr[i + <span class="number">1</span>] = arr[i];</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i + <span class="number">1</span>] = key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5 0 1 2 3 4</span><br></pre></td></tr></table></figure><p>可以看到，该伪代码从实现角度来看并不正确  </p><p>实现时正确的写法应该是如下的这个版本：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">INSERTION-SORT(A)</span><br><span class="line">    for j &lt;- 1 to length[A]</span><br><span class="line">        do key &lt;- A[j]</span><br><span class="line">           // Insert A[j] into the sorted sequence A[1..j-1]</span><br><span class="line">           i &lt;- j - 1</span><br><span class="line">           while i &gt;= 0 and A[i] &gt; key</span><br><span class="line">               do A[i+1] &lt;- A[i]</span><br><span class="line">                  i &lt;- i - 1</span><br><span class="line">           A[i+1] &lt;- key</span><br></pre></td></tr></table></figure><p>下面给出该版本伪代码的 C++ 实现：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="type">int</span> key = arr[j];</span><br><span class="line">        <span class="type">int</span> i = j - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; arr[i] &gt; key) &#123;</span><br><span class="line">            arr[i + <span class="number">1</span>] = arr[i];</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i + <span class="number">1</span>] = key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这回输出对了：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5 6</span><br></pre></td></tr></table></figure><p>我觉得可以认为，《算法导论》给出的伪代码认为 —— 数组的下标从 <code>1</code> 开始。PPT 中给出的伪代码就在首行做出了说明：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: A[1..n] is an array of numbers</span><br><span class="line">for j &lt;- 2 to n do </span><br><span class="line">    key &lt;- A[j];</span><br><span class="line">    i &lt;- j - 1;</span><br><span class="line">    while i &gt;= 1 and A[i] &gt; key do </span><br><span class="line">        A[i+1] &lt;- A[i];</span><br><span class="line">        i &lt;- i - 1;</span><br><span class="line">    end</span><br><span class="line">    A[i+1] &lt;- key;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h4 id="循环不变式证明插入排序正确性"><a href="#循环不变式证明插入排序正确性" class="headerlink" title="循环不变式证明插入排序正确性"></a>循环不变式证明插入排序正确性</h4><img class=".png An example of a loop invariant"><h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><p>算法分析指对一个算法所需要的资源进行预测。这种资源可能是：  </p><ul><li>时间复杂度 (Time Complexity)</li><li>空间复杂度 (Space Complexity)：内存  </li></ul><p>这门课主要关注时间复杂度  </p><p>《算法导论》主要采用 RAM 计算模型来分析算法，在 RAM 模型中，指令一条接一条地执行，没有并发操作  </p><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><h4 id="输入规模-Input-Size"><a href="#输入规模-Input-Size" class="headerlink" title="输入规模 (Input Size)"></a>输入规模 (Input Size)</h4><p>输入规模的概念与具体问题有关，大多数时候，输入规模指的是输入中的元素个数；但有的时候，可能用输入数在二进制表示下的位数来度量输入规模更合适；还有可能是两个数  </p><h4 id="运行时间"><a href="#运行时间" class="headerlink" title="运行时间"></a>运行时间</h4><p>算法的运行时间指的是特定输入下，算法所执行的基本操作数<br>我们认为每执行一行伪代码需要花一定时间，并且假定每次执行第 i 行伪代码所花的时间都是常量 $c_i$  </p><h4 id="三种情况"><a href="#三种情况" class="headerlink" title="三种情况"></a>三种情况</h4><p>对于给定规模的输入，一个算法的运行时间可能要依赖于给定的输入是哪种输入，根据给定输入的不同，算法的运行时间一般可分为三种情况：  </p><ul><li>最佳情况 (Best Case)：没啥用  </li><li>最坏情况 (Worst Case)：最常用  </li><li>平均情况 (Average Case)：通常和最坏情况一样差，但特定情况下会有用  </li></ul><h3 id="插入排序算法的分析"><a href="#插入排序算法的分析" class="headerlink" title="插入排序算法的分析"></a>插入排序算法的分析</h3><p>通过对插入排序算法的分析，对分析算法有个更直观的认识<br>下面得出 INSERTION-SORT 运行时间的表达式<br>首先给出 INSERTION-SORT 过程中，每条指令的执行时间及执行次数。对 $j = 2, 3, …, n, n=length[A]$，设 $t_j$ 为第 5 行中 <code>while</code> 循环做的测试次数。当 <code>for</code> 或 <code>while</code> 循环以通常方式退出，测试要比循环体多执行一次。并假设注释不占用运行时间。  </p><img class="-1.png The Pseudocode of INSERTION-SORT">  <p>（这张图是从《算法导论》里截出来的，我认为第 4 行应该是 <code>i &lt;- j - 1</code>）<br>简单求和可以得到 INSERTION-SORT 运行时间的表达式：  </p><script type="math/tex; mode=display">T(n) = c_1n + c_2(n - 1) + c_4(n-1) + c_5\sum_{j=2}^{n} t_j + c_6\sum_{j=2}^{n} (t_j - 1) + c_7\sum_{j=2}^{n} (t_j - 1) + c_8 (n - 1)</script><p>对于 INSERTION-SORT，如果输入数组已经排好序了，就会出现最佳情况，此时运行时间为：  </p><script type="math/tex; mode=display">\begin{aligned}T(n) = c_1n + c_2 (n - 1) + c_4 (n - 1) + c_5(n - 1) + c_8 (n - 1) \\= (c_1 + c_2 + c_4 + c_5 + c_8)n - (c_2 + c_4 + c_5 + c_8)\end{aligned}</script><p>当输入数组是逆序时，就会出现最坏情况，此时运行时间为：  </p><script type="math/tex; mode=display">\begin{aligned}T(n) = c_1n + c_2 (n - 1) + c_4 (n - 1) + c_5 (\frac{n(n-1)}{2}) + c_8 (n - 1) \\= (\frac{c_5}{2} + \frac{c_6}{2} + \frac{c_7}{2})n^2 + (c_1 + c_2 + c_4 + \frac{c_5}{2} - \frac{c_6}{2} - \frac{c_7}{2} + c_8)n - (c_2 + c_4 + c_5 + c_8)\end{aligned}</script><h3 id="增长量级"><a href="#增长量级" class="headerlink" title="增长量级"></a>增长量级</h3><p>在之前的分析中，我们已经做了一些简化抽象：忽略每条语句的真实代价，用常量 $c_i$ 表示<br>接下来再做进一步的抽象——运行时间的 <strong>增长率</strong> (rate of growth)，或称 <strong>增长的量级</strong> (order of growth)。我们只考虑公式中的最高次项。举个例子，插入排序的最坏情况时间代价为 $O(n^2)$  </p><h2 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h2><p>算法设计有很多方法，之前介绍的插入排序使用的是 <strong>增量(incremental)</strong> 方法，而本节主要介绍另一种设计策略 —— <strong>分治法(divide-and-conquer)</strong>  </p><h3 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h3><p>所谓 <strong>分治策略</strong> 指：将原问题划分成 $n$ 个规模较小而结构与原问题相似的子问题，递归地解决这些子问题，然后再合并其结果，就得到原问题的解    </p><h4 id="分治法的步骤"><a href="#分治法的步骤" class="headerlink" title="分治法的步骤"></a>分治法的步骤</h4><p>分治模式在每一层递归中，都包含三个步骤：  </p><ul><li><strong>分解 (Divide)</strong>  将原问题分解为一系列子问题</li><li><strong>解决 (Conquer)</strong>  递归地解决这些子问题，若子问题足够小，则直接求解</li><li><strong>合并 (Combine)</strong>  将子问题的解合并成原问题的解  </li></ul><p>下面用分治法设计一个排序算法，使其性能显著优于插入排序  </p><h4 id="归并排序-Merge-Sort"><a href="#归并排序-Merge-Sort" class="headerlink" title="归并排序(Merge Sort)"></a>归并排序(Merge Sort)</h4><p>Merge Sort 完全依照分治模式，可从分治模式的三个步骤对其做分析：  </p><ul><li><strong>分解</strong>  将 $n$ 个元素分成各含 $\frac{n}{2}$ 个元素的子序列  </li><li><strong>解决</strong>  用归并排序对两个子序列递归地排序</li><li><strong>合并</strong>  合并两个已排序的子序列  </li></ul><p>在归并排序中，在对子序列排序时，其长度为 1 时递归结束  </p>]]></content>
      
      
      <categories>
          
          <category> AlgoNote </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA-Course-Notes </tag>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
